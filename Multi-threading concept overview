Great üëç
Below is a **complete, clean, interview-ready explanation of Multithreading** with **proper code examples**, starting from **basic ‚Üí intermediate ‚Üí important concepts**.
You can **write these examples directly in an interview**.

---

# üî∑ What is Multithreading?

**Multithreading** is the ability of a program to execute **multiple threads simultaneously** to improve **CPU utilization** and **performance**.

üëâ A **thread** is the **smallest unit of execution** inside a process.

---

## üîπ Why Multithreading?

* Better CPU utilization
* Faster execution
* Responsive applications
* Parallel task execution

---

# 1Ô∏è‚É£ Creating Thread using `Thread` class

### Code Example

```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread is running: " + Thread.currentThread().getName());
    }
}

public class ThreadExample1 {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // starts new thread

        System.out.println("Main thread: " + Thread.currentThread().getName());
    }
}
```

### Output (order may vary)

```
Main thread: main
Thread is running: Thread-0
```

---

### üîë Explanation

* `start()` ‚Üí creates a new thread
* JVM calls `run()` internally
* Execution order is **not guaranteed**

---

# 2Ô∏è‚É£ Creating Thread using `Runnable` (BEST PRACTICE)

### Code Example

```java
class MyTask implements Runnable {
    @Override
    public void run() {
        System.out.println("Task running by: " + Thread.currentThread().getName());
    }
}

public class ThreadExample2 {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyTask());
        t1.start();
    }
}
```

### üî• Why `Runnable` is better?

* Supports **multiple inheritance**
* Loose coupling
* Recommended by Java

---

### üî• Interview Line

> Runnable is preferred because Java does not support multiple inheritance with classes.

---

# 3Ô∏è‚É£ `start()` vs `run()` (MUST KNOW)

```java
MyThread t = new MyThread();
t.run();   // ‚ùå no multithreading
t.start(); // ‚úÖ multithreading
```

| start()            | run()         |
| ------------------ | ------------- |
| New thread         | No new thread |
| Parallel execution | Sequential    |
| JVM controlled     | Normal method |

---

# 4Ô∏è‚É£ Thread Lifecycle (Short)

```
NEW ‚Üí RUNNABLE ‚Üí RUNNING ‚Üí TERMINATED
```

* NEW ‚Üí Thread created
* RUNNABLE ‚Üí start() called
* RUNNING ‚Üí CPU allocated
* TERMINATED ‚Üí run() finished

---

# 5Ô∏è‚É£ Multiple Threads Example

```java
class NumberThread extends Thread {
    public void run() {
        for(int i = 1; i <= 5; i++) {
            System.out.println(Thread.currentThread().getName() + " : " + i);
        }
    }
}

public class MultiThreadDemo {
    public static void main(String[] args) {
        NumberThread t1 = new NumberThread();
        NumberThread t2 = new NumberThread();

        t1.start();
        t2.start();
    }
}
```

### Output (mixed)

```
Thread-0 : 1
Thread-1 : 1
Thread-0 : 2
Thread-1 : 2
...
```

‚úî Shows **true concurrency**

---

# 6Ô∏è‚É£ `sleep()` Example

```java
class SleepDemo extends Thread {
    public void run() {
        try {
            Thread.sleep(1000);
            System.out.println("After 1 second");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class SleepTest {
    public static void main(String[] args) {
        new SleepDemo().start();
    }
}
```

---

# 7Ô∏è‚É£ `join()` Example (Control Execution Order)

```java
class JoinDemo extends Thread {
    public void run() {
        System.out.println("Thread completed");
    }
}

public class JoinTest {
    public static void main(String[] args) throws InterruptedException {
        JoinDemo t = new JoinDemo();
        t.start();
        t.join();   // main waits
        System.out.println("Main finished");
    }
}
```

### Output

```
Thread completed
Main finished
```

---

# 8Ô∏è‚É£ Synchronization (Prevent Data Inconsistency)

### Without Synchronization ‚ùå

```java
class Counter {
    int count = 0;
    void increment() {
        count++;
    }
}
```

### With Synchronization ‚úÖ

```java
class Counter {
    int count = 0;

    synchronized void increment() {
        count++;
    }
}
```

### Usage

```java
class CounterThread extends Thread {
    Counter c;
    CounterThread(Counter c) {
        this.c = c;
    }
    public void run() {
        for(int i = 0; i < 1000; i++)
            c.increment();
    }
}

public class SyncDemo {
    public static void main(String[] args) throws Exception {
        Counter c = new Counter();
        CounterThread t1 = new CounterThread(c);
        CounterThread t2 = new CounterThread(c);

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Final Count: " + c.count);
    }
}
```

---

# 9Ô∏è‚É£ Real-Life Analogy (Easy to Explain)

> Main thread is like a **manager**
> Worker threads are **employees**
> Manager assigns tasks and continues his work

---

# üî• FINAL INTERVIEW SUMMARY

* `start()` creates a new thread
* `run()` is normal method
* Order of execution is unpredictable
* `Runnable` is preferred
* `synchronized` prevents race condition
* Threads improve performance

---

If you want next:

* **Deadlock**
* **Inter-thread communication**
* **wait(), notify(), notifyAll()**
* **Executor framework**

Just tell me üëç
