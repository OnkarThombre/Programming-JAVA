package equals_method;

class Student
{
	 private String name;
	 private int age;
	 
	 public Student() 
	 {
		 this("Onkar" , 23);
	 }
	 
	 public Student(String name , int age)
	 {
		 this.name = name;
		 this.age = age; 
	 }
	 
	 public void display()
	 {
		 System.out.println("Name : "+name + ", Age : "+ age );
	 }
	 
	 public boolean equals(Object obj)
	 {
		 if(obj == null)
		 {
			 return false;
		 }
		 
		 if(obj == this)
		 {
			 return true;
		 }
		 
		 if(obj instanceof Student)
		 {
			 Student std = (Student)obj;
			 
			 if(this.age == std.age && this.name.equals(std.name))//this.name == std.name)  on String check on equals() bcz == compares references on string
			 {
				 return true;
			 }
		 }
		 
			 return false;
		 
				 
	 }
}

public class Equals_Method {
	public static void main(String[] args) {
		Student s1 = new Student();
		Student s2 = new Student();
		
		System.out.println(s1.equals(s2));
		
	}
}

/*

Yes â€” **your `equals()` method is now correct.**
You fixed the main issue (using `this.name.equals(std.name)` instead of `==`).
Let me verify it step-by-step and explain why it is correct.

---

# âœ… **Your equals() method â€“ Is it correct?**

Here is your method:

```java
public boolean equals(Object obj)
{
     if(obj == null)
     {
         return false;
     }

     if(obj == this)
     {
         return true;
     }

     if(obj instanceof Student)
     {
         Student std = (Student)obj;

         if(this.age == std.age && this.name.equals(std.name))
         {
             return true;
         }
     }

     return false;
}
```

### âœ” Checks for null â†’ correct

### âœ” Checks if both references point to same object â†’ correct

### âœ” Checks `instanceof` â†’ correct

### âœ” Downcasting â†’ correct

### âœ” Comparing `age` using `==` â†’ correct (primitive)

### âœ” Comparing `name` using `.equals()` instead of `==` â†’ correct

### â­ FINAL RESULT: **Your equals() implementation is logically correct**

This will properly compare **two Student objects** based on `name` and `age`.

---

# âš  BUT NOTE: You should **also override hashCode()**

### If you plan to use `Student` in:

* HashSet
* HashMap keys
* HashTable
* LinkedHashSet

Then Java requires:

ğŸ‘‰ **When equals() is overridden, hashCode() MUST also be overridden.**

Otherwise, HashSet / HashMap will behave incorrectly (may store duplicates).

---

# âœ” RECOMMENDED hashCode() implementation

Here is the correct hashCode() for your class:

```java
@Override
public int hashCode() {
    int result = 17;          // any prime number
    result = 31 * result + age;
    result = 31 * result + (name == null ? 0 : name.hashCode());
    return result;
}
```

---

# ğŸ“Œ Why you **must** override hashCode too?

Because the contract says:

> If two objects are equal according to equals(),
> then they must have the same hashCode().

Otherwise, collections like HashSet will treat them as different objects.

---

# âœ” Output of your program

```java
Student s1 = new Student();
Student s2 = new Student();
System.out.println(s1.equals(s2));
```

Both objects are:

```
name = "Onkar"
age = 23
```

So equals returns **true**.

---

# ğŸ¯ Conclusion

### âœ” Yes, your equals method is correct.

### âœ” You fixed the important String comparison issue.

### â— Just add hashCode() if using in collections.

---

If you want, I can also show:

âœ… How equals() + hashCode() works internally in HashSet buckets (diagram)
âœ… How to test your equals method
âœ… What happens if you do NOT override hashCode()

Just tell me!


*/
